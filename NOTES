1. Estimate the component fractions using a bayesian framework
	-uniform prior
	-posterior drawn from Dirichlet distribution

	Process within implementation:
		i. create 'frac' array with shape n, m filled with ones
		ii. for each sample (as rows) from the 'count' array, add 1 to all observations
		ii. with this new sample row as alpha, draw from Dirichlet distribution and then add to 'frac'

			import numpy as np
			np.random.seed(18724)
			counts = np.random.random_integers(5, size=(5,10))
			n, m = np.shape(counts)
			fractions = np.ones((n, m))
			for i in range(n):
				count_row = counts[i, ]
				dirichlet_param = count_row + 1
				fractions[i, ] = np.random.mtrand.dirichlet(dirichlet_param)

	Succiently
	a. for each row in sample counts, add pseudocount
	b. row with pseudocount as alpha parameter and draw from Dirichlet distribution
	c. construct array from Dirichlet distribution sample rows


2. With component fraction estimation calculate the log-ratio variances
	Process within implmentation
		i.  get combination of each OTU column and calculate the 1-d log ratio array
		ii. with each 1-d log ratio array, call nump.var with ddof=1 (gives unbiased esimator rather than the ML one)
		ii. add variance of OTU column combination to a new square array (variance_array[i,j] = variance_array[j,i] = variance)

			variance_array = np.zeros((m ,m))
			for i in range(m-1):
				for j in range(i+1, m):
				        log_ratio = np.array(np.log(fractions[: ,i]/fractions[: ,j]))
				        variance_array[i,j] = variance_array[j,i] = np.var(log_ratio, ddof=1)

3. Compute the component variations
	-takes both the variance_array and fractions array

		Process within implementation
			k = len(variance_array)
			variance_vector = variance_array.sum(axis = 1)
			cov_array = np.matrix(np.zeros((k, k)))
			cov_vector = (cov_array - np.diag(np.diag(cov_array))).sum(axis=1)
			mod_array = np.matrix(np.ones((k, k)) + np.diag([m-2]*m))
			basis_variance = mod_array.I * (variance_vector + 2 * cov_vector)
			basis_variance[basis_variance < 0] = 1e-4


4. Calculate cor and cov from the estimated basis variances and observed fractions variation matrix
	-takes both variance_array and basis_variations



5. Exclude iterations
	-takes both the variance_array and fractions array
	-a list of excluded idicies (e.g. [i,j]) of highly correlated OTUs (th > 0.1)
